'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var _extends = require('@babel/runtime/helpers/extends');
var React = require('react');
var reactUse = require('react-use');
var hoistNonReactStatics = require('hoist-non-react-statics');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _objectWithoutPropertiesLoose__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutPropertiesLoose);
var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var hoistNonReactStatics__default = /*#__PURE__*/_interopDefaultLegacy(hoistNonReactStatics);

var clamp = function clamp(num, lower, upper) {
  num = num <= upper ? num : upper;
  num = num >= lower ? num : lower;
  return num;
};

var increment = function increment(progress) {
  var amount = 0;

  if (progress >= 0 && progress < 0.2) {
    amount = 0.1;
  } else if (progress >= 0.2 && progress < 0.5) {
    amount = 0.04;
  } else if (progress >= 0.5 && progress < 0.8) {
    amount = 0.02;
  } else if (progress >= 0.8 && progress < 0.99) {
    amount = 0.005;
  }

  return clamp(progress + amount, 0, 0.994);
};

var isRunning = false;
var pending = [];

var next = function next() {
  isRunning = true;
  var cb = pending.shift();

  if (cb) {
    return cb(next);
  }

  isRunning = false;
};

var clear = function clear() {
  isRunning = false;
  pending = [];
};
var queue = function queue(cb) {
  pending.push(cb);

  if (!isRunning && pending.length === 1) {
    next();
  }
};

var handle;
var cancel = function cancel() {
  if (handle) {
    window.cancelAnimationFrame(handle);
  }
};
var timeout = function timeout(callback, delay) {
  var deltaTime;
  var start;

  var frame = function frame(time) {
    start = start || time;
    deltaTime = time - start;

    if (deltaTime > delay) {
      callback();
      return;
    }

    handle = window.requestAnimationFrame(frame);
  };

  handle = window.requestAnimationFrame(frame);
};

/* istanbul ignore next */

var noop = function noop() {
  return undefined;
};

var initialState = {
  isFinished: false,
  progress: 0,
  sideEffect: noop
};

var cleanup = function cleanup() {
  cancel();
  clear();
};

var useNProgress = function useNProgress(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$animationDuratio = _ref.animationDuration,
      animationDuration = _ref$animationDuratio === void 0 ? 200 : _ref$animationDuratio,
      _ref$incrementDuratio = _ref.incrementDuration,
      incrementDuration = _ref$incrementDuratio === void 0 ? 800 : _ref$incrementDuratio,
      _ref$isAnimating = _ref.isAnimating,
      isAnimating = _ref$isAnimating === void 0 ? false : _ref$isAnimating,
      _ref$minimum = _ref.minimum,
      minimum = _ref$minimum === void 0 ? 0.08 : _ref$minimum;

  var _useGetSetState = reactUse.useGetSetState(initialState),
      get = _useGetSetState[0],
      setState = _useGetSetState[1];

  var set = React.useCallback(function (n) {
    n = clamp(n, minimum, 1);

    if (n === 1) {
      cleanup();
      queue(function (next) {
        setState({
          progress: n,
          sideEffect: function sideEffect() {
            return timeout(next, animationDuration);
          }
        });
      });
      queue(function () {
        setState({
          isFinished: true,
          sideEffect: cleanup
        });
      });
      return;
    }

    queue(function (next) {
      setState({
        progress: n,
        sideEffect: function sideEffect() {
          return timeout(next, animationDuration);
        }
      });
    });
  }, [animationDuration, minimum, setState]);
  var trickle = React.useCallback(function () {
    set(increment(get().progress));
  }, [get, set]);
  var start = React.useCallback(function () {
    var work = function work() {
      trickle();
      queue(function (next) {
        timeout(function () {
          work();
          next();
        }, incrementDuration);
      });
    };

    work();
  }, [incrementDuration, trickle]);
  var savedTrickle = React.useRef(noop);
  var sideEffect = get().sideEffect;
  React.useEffect(function () {
    savedTrickle.current = trickle;
  });
  reactUse.useEffectOnce(function () {
    if (isAnimating) {
      start();
    }

    return cleanup;
  });
  reactUse.useUpdateEffect(function () {
    get().sideEffect();
  }, [get, sideEffect]);
  reactUse.useUpdateEffect(function () {
    if (!isAnimating) {
      set(1);
    } else {
      setState(_extends__default['default']({}, initialState, {
        sideEffect: start
      }));
    }
  }, [isAnimating, set, setState, start]);
  return {
    animationDuration: animationDuration,
    isFinished: get().isFinished,
    progress: get().progress
  };
};

var NProgress = function NProgress(_ref) {
  var children = _ref.children,
      restProps = _objectWithoutPropertiesLoose__default['default'](_ref, ["children"]);

  var renderProps = useNProgress(restProps);
  return children(renderProps);
};

function withNProgress(BaseComponent) {
  var WithNProgress = function WithNProgress(props) {
    var hookProps = useNProgress(props);
    return /*#__PURE__*/React.createElement(BaseComponent, Object.assign({}, props, hookProps));
  };

  hoistNonReactStatics__default['default'](WithNProgress, BaseComponent);
  return WithNProgress;
}

exports.NProgress = NProgress;
exports.useNProgress = useNProgress;
exports.withNProgress = withNProgress;
//# sourceMappingURL=react-nprogress.cjs.development.js.map
