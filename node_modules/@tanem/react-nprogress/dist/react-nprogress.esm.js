import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';
import _extends from '@babel/runtime/helpers/extends';
import { useCallback, useRef, useEffect, createElement } from 'react';
import { useGetSetState, useEffectOnce, useUpdateEffect } from 'react-use';
import hoistNonReactStatics from 'hoist-non-react-statics';

var clamp = function clamp(num, lower, upper) {
  num = num <= upper ? num : upper;
  num = num >= lower ? num : lower;
  return num;
};

var increment = function increment(progress) {
  var amount = 0;

  if (progress >= 0 && progress < 0.2) {
    amount = 0.1;
  } else if (progress >= 0.2 && progress < 0.5) {
    amount = 0.04;
  } else if (progress >= 0.5 && progress < 0.8) {
    amount = 0.02;
  } else if (progress >= 0.8 && progress < 0.99) {
    amount = 0.005;
  }

  return clamp(progress + amount, 0, 0.994);
};

var isRunning = false;
var pending = [];

var next = function next() {
  isRunning = true;
  var cb = pending.shift();

  if (cb) {
    return cb(next);
  }

  isRunning = false;
};

var clear = function clear() {
  isRunning = false;
  pending = [];
};
var queue = function queue(cb) {
  pending.push(cb);

  if (!isRunning && pending.length === 1) {
    next();
  }
};

var handle;
var cancel = function cancel() {
  if (handle) {
    window.cancelAnimationFrame(handle);
  }
};
var timeout = function timeout(callback, delay) {
  var deltaTime;
  var start;

  var frame = function frame(time) {
    start = start || time;
    deltaTime = time - start;

    if (deltaTime > delay) {
      callback();
      return;
    }

    handle = window.requestAnimationFrame(frame);
  };

  handle = window.requestAnimationFrame(frame);
};

/* istanbul ignore next */

var noop = function noop() {
  return undefined;
};

var initialState = {
  isFinished: false,
  progress: 0,
  sideEffect: noop
};

var cleanup = function cleanup() {
  cancel();
  clear();
};

var useNProgress = function useNProgress(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$animationDuratio = _ref.animationDuration,
      animationDuration = _ref$animationDuratio === void 0 ? 200 : _ref$animationDuratio,
      _ref$incrementDuratio = _ref.incrementDuration,
      incrementDuration = _ref$incrementDuratio === void 0 ? 800 : _ref$incrementDuratio,
      _ref$isAnimating = _ref.isAnimating,
      isAnimating = _ref$isAnimating === void 0 ? false : _ref$isAnimating,
      _ref$minimum = _ref.minimum,
      minimum = _ref$minimum === void 0 ? 0.08 : _ref$minimum;

  var _useGetSetState = useGetSetState(initialState),
      get = _useGetSetState[0],
      setState = _useGetSetState[1];

  var set = useCallback(function (n) {
    n = clamp(n, minimum, 1);

    if (n === 1) {
      cleanup();
      queue(function (next) {
        setState({
          progress: n,
          sideEffect: function sideEffect() {
            return timeout(next, animationDuration);
          }
        });
      });
      queue(function () {
        setState({
          isFinished: true,
          sideEffect: cleanup
        });
      });
      return;
    }

    queue(function (next) {
      setState({
        progress: n,
        sideEffect: function sideEffect() {
          return timeout(next, animationDuration);
        }
      });
    });
  }, [animationDuration, minimum, setState]);
  var trickle = useCallback(function () {
    set(increment(get().progress));
  }, [get, set]);
  var start = useCallback(function () {
    var work = function work() {
      trickle();
      queue(function (next) {
        timeout(function () {
          work();
          next();
        }, incrementDuration);
      });
    };

    work();
  }, [incrementDuration, trickle]);
  var savedTrickle = useRef(noop);
  var sideEffect = get().sideEffect;
  useEffect(function () {
    savedTrickle.current = trickle;
  });
  useEffectOnce(function () {
    if (isAnimating) {
      start();
    }

    return cleanup;
  });
  useUpdateEffect(function () {
    get().sideEffect();
  }, [get, sideEffect]);
  useUpdateEffect(function () {
    if (!isAnimating) {
      set(1);
    } else {
      setState(_extends({}, initialState, {
        sideEffect: start
      }));
    }
  }, [isAnimating, set, setState, start]);
  return {
    animationDuration: animationDuration,
    isFinished: get().isFinished,
    progress: get().progress
  };
};

var NProgress = function NProgress(_ref) {
  var children = _ref.children,
      restProps = _objectWithoutPropertiesLoose(_ref, ["children"]);

  var renderProps = useNProgress(restProps);
  return children(renderProps);
};

function withNProgress(BaseComponent) {
  var WithNProgress = function WithNProgress(props) {
    var hookProps = useNProgress(props);
    return /*#__PURE__*/createElement(BaseComponent, Object.assign({}, props, hookProps));
  };

  hoistNonReactStatics(WithNProgress, BaseComponent);
  return WithNProgress;
}

export { NProgress, useNProgress, withNProgress };
//# sourceMappingURL=react-nprogress.esm.js.map
